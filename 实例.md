[TOC]

说明：

1. 稳定性是指：排序后原来相等的元素是否能保持相对位置不变
2. 难度和时间复杂度都是从网上抄的，代码是自己写的
3. 当**数据比较小**的时候可以加一个**插入排序**

# 十大排序

## 比较类排序

### 交换排序

#### 冒泡排序

> 难度：&#x2605;

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| ------------------ | ------------------ | ------------------ | ---------- | ------ |
| $O(n^2)$           | $O(n)$             | $O(n^2)$           | $O(1)$     | 稳定   |

```c++
#include <iostream>
using namespace std;

void bubbleSort(int arr[], int len)
{
    for (int i = 0; i < len; ++i)
        for (int j = 0; j < len - i - 1; ++j)
            if (arr[j] > arr[j + 1])
                swap(arr[j], arr[j + 1]);
}

int main()
{
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int len = sizeof(arr) / sizeof(arr[0]);
    for (int i : arr)
        cout << i << " ";
    cout << endl;
    bubbleSort(arr, len);
    for (int i : arr)
    	cout << i << " ";
    cout << endl;
}
```

---

<div style = "page-break-after: always;">
</div>

> **能否对冒泡排序给出优化？**

> 1. **设置标志位置**

```c++
void bubbleSort(int arr[], int len)
{
    bool flag = true;
    for (int i = 0; i < len && flag; ++i)
    {
        flag = false;
        for (int j = 0; j < len - i - 1; ++j)
            if (arr[j] > arr[j + 1])
            {
                swap(arr[j], arr[j + 1]);
                flag = true;
            }
    }
}
```

---


> 2. 记录最后一次交换位置

```c++
void bubbleSort(int arr[], int len)
{
    int lastSwapped = len - 1;
    int newLastSwapped;
    while (lastSwapped > 0)
    {
		newLastSwapped = 0;
        for (int j = 0; j < lastSwapped; ++j)
            if (arr[j] > arr[j + 1])
            {
                swap(arr[j], arr[j + 1]);
                newLastSwapped = j;
            }
        lastSwapped = newLastSwapped;
    }
}
```

---

> 3. 鸡尾酒排序(双向冒泡排序)

```c++
void bubbleSort(int arr[], int len)
{
    bool swapped = true;
    int start = 0;
    int end = n - 1;
    
    while (swapped)
    {
        swapped = false;
        for (int i = start; i < end; ++i)
            if (arr[i] > arr[i + 1])
            {
                swap(arr[i], arr[i + 1]);
                swapped = true;
            }
        
        if (!swapped)
        	break;
        
        swapped = false;
        --end;
        
        for (int i = end - 1; i >= start; --i)
            if (arr[i] > arr[i + 1])
            {
            	swap(arr[i], arr[i + 1]);
                swapped = true;
            }
        ++start;
    }
}
```

---

<div style = "page-break-after: always;">
</div>

#### 快速排序

> C语言的`qsort`，C++的`sort`，都是基于快速排序。可以直接使用
>
> 难度：&#x2605;&#x2605;&#x2605;&#x2605;

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度        | 稳定性 |
| ------------------ | ------------------ | ------------------ | ----------------- | ------ |
| $O(n\log_{2}{n})$  | $O(n\log_{2}{n})$  | $O(n^2)$           | $O(n\log_{2}{n})$ | 不稳定 |

```c++
#include <iostream>
using namespace std;

int partition(int arr[], int l, int r) //将数组进行分区
{
    int pivot = arr[r]; //选择最后一个元素当做基准
    int i = l - 1; //初始化i为分区点前一个位置
    
    for (int j = l; j < r; ++j)
        if (arr[j] < pivot)
        {
            ++i;
            swap(arr[i], arr[j]);
        }
    
    swap(arr[i + 1], arr[r]); //将基准元素放到正确的位置
    return i + 1;
}

void quickSort(int arr[], int l, int r)
{
    if (l < r)
    {
        int pi = partition(arr, l, r);
        quickSort(arr, l, pi - 1); //对左侧分区进行快速排序
        quickSort(arr, pi + 1, r); //对右侧分区进行快速排序
    }
}

int main()
{
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int len = sizeof(arr) / sizeof(arr[0]);
    
    for (int i : arr)
        cout << i << " ";
    cout << endl;
     
    quickSort(arr, 0, len - 1);
    
    for (int i : arr)
    	cout << i << " ";
    cout << endl;
}
```

---

<div style = "page-break-after: always";>
</div>

> 快排什么时候效率最低呢？怎么避免呢？
>
> 怎么优化快排的时间复杂度呢？


> 三路取中快速排序

```c++
void qucikSort(vector<int> &nums, int left, int right)
{
	if (left >= right)
		return;

	int pivot = nums[left];
	int lt = left, gt = right + 1;
	int i = left + 1;

	while (i < gt)
	{
		if (nums[i] < pivot)
		{
			swap(nums[i], nums[lt + 1]);
			lt++, i++;
		}
		else if (nums[i] > pivot)
		{
			swap(nums[i], nums[gt - 1]);
			gt--;
		}
		else
			i++;
	}

	swap(nums[left], nums[lt]);
	qucikSort(nums, left, lt - 1);
	qucikSort(nums, gt, right);
}
```

---

> 随机快速排序

```c++
void qucikSort(vector<int> &nums, int left, int right)
{
	if (left >= right)
		return;

	int index = rand() % (right - left + 1) + left;
	int pivot = nums[index];
	swap(nums[left], nums[index]);
   
    // ···与上面相同
}
```

---

<div style = "page-break-after: always";>
</div>

### 插入排序

#### 简单插入排序

> 难度：&#x2605;&#x2605;

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| ------------------ | ------------------ | ------------------ | ---------- | ------ |
| $O(n^2)$           | $O(n)$             | $O(n^2)$           | $O(1)$     | 稳定   |

```c++
#include <iostream>
using namespace std;

void insertionSort(int arr[], int len)
{
	for (int i = 1; i < len; ++i)
	{
		int cur = arr[i];
		int j = i - 1;
		for (; j >= 0 && arr[j] > cur; --j)
			arr[j + 1] = arr[j];

		arr[j + 1] = cur;
	}
}

int main()
{
	int arr[] = {64, 34, 25, 12, 22, 11, 90};
	int len = sizeof(arr) / sizeof(arr[0]);

	for (int i : arr)
		cout << i << " ";
	cout << endl;

	insertionSort(arr, len);

	for (int i : arr)
		cout << i << " ";
	cout << endl;
}
```

---

<div style = "page-break-after: always;">
</div>

> 如何对插入排序进行优化

> 1. 二分插入排序

```c++
void binaryInsertionSort(int arr[], int n)
{
    for (int i = 1; i < n; ++i)
    {
        int cur = arr[i];
        int left = 0, right = i - 1;
        
        while (left <= right)
        {
            int mid = left + (right - left) / 2; //为什么这样写？因为怕两个加起来爆int
            if (arr[mid] < cur)
                left = mid + 1;
            else
                right = mid - 1;
        }
        
        for (int j = i - 1; j >= left; --j)
            arr[j + 1] = arr[j];
        arr[left] = cur;
    }
}
```

---


> 2. 线性插入排序 (使用链表实现，这里给出一个不完整的示例代码)

```c++
struct Node
{
    int data;
    Node* next;

    Node(int value) : data(value), next(nullptr) {}
};

void insertNode(Node* head, Node* newNode)
{
    Node* current = head;
    while (current->next != nullptr && current->next->data < newNode->data)
        current = current->next;
    
    newNode->next = current->next;
    current->next = newNode;
}

void linearInsertionSort(Node* head)
{
    if (head == nullptr || head->next == nullptr)
        return;
    
    Node* sortedList = nullptr;
    Node* current = head;
    while (current != nullptr)
    {
        Node* next = current->next;
        insertNode(sortedList, current);
        current = next;
    }
    
    // 更新原始链表头指针
    head = sortedList;
}
```

---

<div style = "page-break-after: always";>
</div>

#### 希尔排序

> 希尔排序本质也是简单插入排序的一种优化
>
> 难度：&#x2605;&#x2605;&#x2605;&#x2605;

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| ------------------ | ------------------ | ------------------ | ---------- | ------ |
| $O(n^{1.3})$       | $O(n)$             | $O(n^2)$           | $O(1)$     | 不稳定 |

```c++
#include <iostream>
#include <vector>
using namespace std;

void shellSort(vector<int>& arr)
{
    int n = arr.size();
    for (int gap = n / 2; gap > 0; gap /= 2)
        for (int i = gap; i < n; ++i)
        {
            int temp = arr[i];
            int j = 0;
            for (j = i; j >= gap && arr[j - gap] > temp; j -=gap)
                arr[j] = arr[j - gap];
            arr[j] = temp;
        }
}

int main()
{
    vector<int> vec = {64, 34, 25, 12, 22, 11, 90};
    
    for (int i : vec)
        cout << i << " ";
    cout << endl;
     
    shellSort(vec);
    
    for (int i : vec)
    	cout << i << " ";
    cout << endl;
}
```

---

<div style = "page-break-after: always;">
</div>

### 选择排序

#### 简单选择排序

> 难度：&#x2605;

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| ------------------ | ------------------ | ------------------ | ---------- | ------ |
| $O(n^2)$           | $O(n^2)$           | $O(n^2)$           | $O(1)$     | 不稳定 |

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void selectionSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
		int minIndex = i;
        for (int j = i + 1; j < n; ++j)
            if (vec[j] < vec[minIndex])
                minIndex = j;
        /* 
         * 上面的for循环可被这个代替
         * auto minElementInter = min_element(vec.begin() + i, vec.end());
         */
        swap(vec[i], vec[minIndex]);
        // swap(vec[i], *minElementInter);
    }
}

int main()
{
	vector<int> vec = {64, 34, 25, 12, 22, 11, 90};

	for (int i : vec)
		cout << i << " ";
	cout << endl;

	selectionSort(vec);

	for (int i : vec)
		cout << i << " ";
	cout << endl;
}
```

---

<div style = "page-break-after: always;">
</div>

> 能否对选择排序进行优化？

> 1. 双向选择排序

```c++
void bidrectionalSelectionSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n / 2; ++i)
    {
        int minIndex = i, maxIndex = i;
        for (int j = i + 1; j <= n - i - 1; ++j)
        {
            if (vec[j] < vec[minIndex])
                minIndex = j;
            if (vec[j] > vec[maxIndex])
                maxIndex = j;
        }
        swap(vec[i], vec[minIndex]);
        if (maxIndex == i)
            maxIndex = minIndex;
        swap(vec[n - i - 1], vec[maxIndex]);
    }
}
```

---

> 2. 利用线段树维护（目前还不会）

`````c++

`````

---

<div style = "page-break-after: always;">
</div>
#### 堆排序

> ==**一定要先学会完全二叉树**==
>
> 难度：&#x2605;&#x2605;&#x2605;&#x2605;&#x2605;

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| ------------------ | ------------------ | ------------------ | ---------- | ------ |
| $O(n\log_{2}{n})$  | $O(n\log_{2}{n})$  | $O(n\log_{2}{n})$  | $O(1)$     | 不稳定 |

```c++
#include <iostream>
using namespace std;

void maxHeapify(int arr[], int n, int i)
{
	int largest = i;
	int left = 2 * i + 1;
	int right = 2 * i + 2;

	if (left < n && arr[left] > arr[largest])
		largest = left;
	if (right < n && arr[right] > arr[largest])
		largest = right;
	if (largest != i)
	{
		swap(arr[i], arr[largest]);
		maxHeapify(arr, n, largest);
	}
}

void heapSort(int arr[], int n)
{
	for (int i = n / 2 - 1; i >= 0; --i)
		maxHeapify(arr, n, i);

	for (int i = n - 1; i > 0; --i)
	{
		swap(arr[0], arr[i]);
		maxHeapify(arr, i, 0);
	}
}

int main()
{
	int arr[] = {64, 34, 25, 12, 22, 11, 90};
	int n = sizeof(arr) / sizeof(arr[0]);

	for (int i : arr)
		cout << i << " ";
	cout << endl;

	heapSort(arr, n);

	for (int i : arr)
		cout << i << " ";
	cout << endl;
}
```

---

<div style = "page-break-after: always;">
</div>
### 归并排序

> 难度：&#x2605;&#x2605;&#x2605;

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| ------------------ | ------------------ | ------------------ | ---------- | ------ |
| $O(n\log_{2}{n})$  | $O(n\log_{2}{n})$  | $O(n\log_{2}{n})$  | $O(n)$     | 稳定   |

```c++
#include <iostream>
using namespace std;

void merge(int arr[], int left, int mid, int right)
{
	int n1 = mid - left + 1;
	int n2 = right - mid;
	int l[n1], r[n2];

	for (int i = 0; i < n1; ++i)
		l[i] = arr[left + i];
	for (int j = 0; j < n2; ++j)
		r[j] = arr[mid + 1 + j];

	int i = 0, j = 0, k = left;
	while (i < n1 && j < n2)
	{
		if (l[i] <= r[j])
			arr[k++] = l[i++];
		else
			arr[k++] = r[j++];
	}

	while (i < n1)
		arr[k++] = l[i++];
	while (j < n2)
		arr[k++] = r[j++];
}

void mergeSort(int arr[], int left, int right)
{
	if (left < right)
	{
		int mid = left + (right - left) / 2;
		mergeSort(arr, left, mid);
		mergeSort(arr, mid + 1, right);
		merge(arr, left, mid, right);
	}
}

int main()
{
	int arr[] = {64, 34, 25, 12, 22, 11, 90};
	int n = sizeof(arr) / sizeof(arr[0]);

	for (int i : arr)
		cout << i << " ";
	cout << endl;

	mergeSort(arr, 0, n - 1);

	for (int i : arr)
		cout << i << " ";
	cout << endl;
}
```

---

<div style = "page-break-after: always;">
</div>

> 归并排序的时间复杂度已经很优秀，你能否尝试继续给出优化？

> 1. 利用迭代

````c++
void mergeSort(int arr[], int len)
{
	for (int size = 1; size < len; ++size)
		for (int left = 0; left < len - size; left += 2 * size)
		{
			int mid = left + size - 1;
			int right = min(left + 2 * size - 1, len - 1);
			merge(arr, left, mid, right);
		}
}
````

---

> 2. 减少数据移动

```c++
void merge(vector<int> &nums, int left, int mid, int right)
{
	vector<int> temp(right - left + 1);
	int i = left, j = mid + 1, k = 0;
	while (i <= mid && j <= right)
	{
		if (nums[i] <= nums[j])
			temp[k++] = nums[i++];
		else
			temp[k++] = nums[j++];
	}
	while (i <= mid)
		temp[k++] = nums[i++];
	while (j <= right)
		temp[k++] = nums[j++];

	for (int p = 0; p < k; ++p)
		nums[left + p] = temp[p];
}

void mergeSort(vector<int> &nums, int left, int right)
{
	if (left >= right)
		return;
	int mid = left + (right - left) / 2;
	mergeSort(nums, left, mid);
	mergeSort(nums, mid + 1, right);
	if (nums[mid] > nums[mid + 1])
		merge(nums, left, mid, right);
}
```

---

> 3. 多线程并行

```c++
#include <thread>
// merge函数同2
void mergeSort(vector<int> &nums, int left, int right)
{
	if (left >= right)
		return;
	int mid = left + (right - left) / 2;
	thread t1(mergeSort, ref(nums), left, mid);
	thread t2(mergeSort, ref(nums), mid + 1, right);
	t1.join(), t2.join();
	if (nums[mid] > nums[mid + 1])
		merge(nums, left, mid, right);
}
```

---

<div style = "page-break-after: always;">
</div>
## 非比较排序

> 非比较排序时间复杂度已经是线性的了，因此也很难有优化的余地


### 桶排序

> 难度：&#x2605;&#x2605;&#x2605;
>
> k是**数据范围**

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| ------------------ | ------------------ | ------------------ | ---------- | ------ |
| $O(n+k)$           | $O(n)$             | $O(n^2)$           | $O(n+k)$   | 稳定   |

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

constexpr int maxN = 100; //这是示例实际还可以再修改

void bucketSort(vector<int> &nums)
{
	int n = nums.size();
	vector<vector<int>> buckets(n);
	for (int i = 0; i < n; ++i)
	{
		int bucketIndex = n * nums[i] / maxN; //本质是让后一个桶内所有元素大于前一个桶所有元素，可以选择任何喜欢的方法
		buckets[bucketIndex].push_back(nums[i]);
	}

	for (int i = 0; i < n; ++i)
		sort(buckets[i].begin(), buckets[i].end()); //本质是对桶内元素排序，选择什么方法最好呢？
	int index = 0;
	for (int i = 0; i < n; ++i)
		for (int num : buckets[i])
			nums[index++] = num;
}

int main()
{
	vector<int> nums = {64, 34, 25, 12, 22, 11, 90};

	for (int i : nums)
		cout << i << " ";
	cout << endl;

	bucketSort(nums);

	for (int i : nums)
		cout << i << " ";
	cout << endl;
}
```

> 常情况下，**小规模**的桶（比如每个桶内只有几个元素），**插入排序**是一个不错的选择，因为它在小规模数据上性能较好。
>
> 而对于**大规模**的桶，可以考虑使用**快速排序、归并排序**等高效的排序算法。
>
> 如果**数据量非常大**，且数据**分布较为均匀**，可以考虑使用**并行化的排序**算法，比如**并行快速排序**

> 如何优化桶排序？
>
> 调整桶的数量、选择合适的桶内排序算法、优化桶内排序过程以及并行化处理

---

<div style = "page-break-after: always;">
</div>

### 计数排序

> 难度：&#x2605;&#x2605;&#x2605;
>
> 要求：
>
> 1. 数据类型：**非负整数**或**具有类似于整数的特性**的数
> 2. 数据范围：需要先确定范围
> 3. 数据分布：计数排序适用于**非稀疏的数据集**，如存在大量相同的元素
>
> 本质还是一个桶排序，下表中k表示**数据范围**

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| ------------------ | ------------------ | ------------------ | ---------- | ------ |
| $O(n+k)$           | $O(n+k)$           | $O(n+k)$           | $O(n+k)$   | 稳定   |

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

void countingSort(vector<int> &vec)
{
	int maxElement = *max_element(vec.begin(), vec.end());
	vector<int> count(maxElement + 1, 0); //为什么这里要+1呢？
	vector<int> output(vec.size());

	for (int i = 0; i < vec.size(); ++i)
		++count[vec[i]];
	for (int i = 1; i < count.size(); ++i)
		count[i] += count[i - 1];

	for (int i = vec.size() - 1; i >= 0; --i)
	{
		output[count[vec[i]] - 1] = vec[i];
		--count[vec[i]];
	}

	for (int i = 0; i < vec.size(); ++i)
		vec[i] = output[i];
}

int main()
{
	vector<int> vec = {64, 34, 25, 12, 22, 11, 90};

	for (int i : vec)
		cout << i << " ";
	cout << endl;

	countingSort(vec);

	for (int i : vec)
		cout << i << " ";
	cout << endl;
}
```

> 如何再优化计数排序？
>
> 1. 压缩计数数组：**只记录不同元素的数量**
> 2. 优化计数数组的构建：可以使用**动态数组、哈希表、位图**来代替静态数组

---

<div style = "page-break-after: always;">
</div>
### 基数排序

> 难度：&#x2605;&#x2605;&#x2605;&#x2605;
>
> 本质还是一个桶排序，下表中k表示**最大数字的位数**

| 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| ------------------ | ------------------ | ------------------ | ---------- | ------ |
| $O(n*k)$           | $O(n*k)$           | $O(n*k)$           | $O(n+k)$   | 稳定   |

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

void radixSort(vector<int> &nums)
{
	int maxNum = *max_element(nums.begin(), nums.end());
	int exp = 1;
	auto getDigit = [](int num, int digit) -> int
    {
		return (num / digit) % 10;
	};

	while (maxNum / exp > 0)
	{
		vector<vector<int>> buckets(10);
		for (int i = 0; i < nums.size(); ++i)
		{
			int digit = getDigit(nums[i], exp);
			buckets[digit].push_back(nums[i]);
		}

		int index = 0;
		for (int j = 0; j < 10; ++j)
			for (int num : buckets[j])
				nums[index++] = num;

		exp *= 10;
	}
}

int main()
{
	vector<int> nums = {64, 34, 25, 12, 22, 11, 90};

	for (int i : nums)
		cout << i << " ";
	cout << endl;

	radixSort(nums);

	for (int i : nums)
		cout << i << " ";
	cout << endl;
}

```

---

<div style = "page-break-after: always;">
</div>

> 如果有负数怎么办？


> 方案一，取模分别处理

```c++
void radixSort(vector<int> &nums)
{
	vector<int> negatives;
	vector<int> nonNegatives;

	for (int num : nums)
	{
		if (num < 0)
			negatives.push_back(-num);
		else
			nonNegatives.push_back(num);
	}
    
    //就是上面的radixSort
	PositiveRadixSort(negatives); 
	PositiveRadixSort(nonNegatives);
	for (int &num : negatives)
		num = -num;
	nums.clear();
	nums.insert(nums.end(), negatives.rbegin(), negatives.rend());
	nums.insert(nums.end(), nonNegatives.begin(), nonNegatives.end());
}
```

> 方案二，数据整体偏移

```c++
void radixSort(vector<int> &nums)
{
	int maxNum = *max_element(nums.begin(), nums.end());
	int minNum = *min_element(nums.begin(), nums.end());
	int exp = 1;
	auto getDigit = [](int num, int digit) -> int
    {
		return (num / digit) % 10;
	};

	if (minNum < 0)
	{
		for (int &num : nums)
			num -= minNum;
		maxNum -= minNum;
	}

	while (maxNum / exp > 0)
	{
		vector<vector<int>> buckets(10);
		for (int i = 0; i < nums.size(); ++i)
		{
			int digit = getDigit(nums[i], exp);
			buckets[digit].push_back(nums[i]);
		}

		int index = 0;
		for (int j = 0; j < 10; ++j)
			for (int num : buckets[j])
				nums[index++] = num;

		exp *= 10;
	}

	if (minNum < 0)
		for (int &num : nums)
			num += minNum;
}
```

---

<div style = "page-break-after: always;">
</div>

## 总结

时间复杂度影响排序的选择：

1. 当数据比较小时，如：$n<10^3$，复杂度$O(n^2)$即可
2. 当数据较中等时， 如$n<10^9$，复杂度$O(n\log{n})$即可
3. 当数据比较大时，如：$n\ge10^6$，复杂度$O(n)$​

---



总结下列表格：

|     复杂度      |                        |                            |                            |
| :-------------: | :--------------------: | :------------------------: | :------------------------: |
| $O(n\log_2{n})$ | [快速排序](# 快速排序) |     [堆排序](# 堆排序)     |   [归并排序](# 归并排序)   |
|  $O(n^{1.3})$   | [希尔排序](# 希尔排序) |                            |                            |
|    $O(n^2)$     | [冒泡排序](# 冒泡排序) | [插入排序](# 简单插入排序) | [选择排序](# 简单选择排序) |
|      其他       |   [桶排序](# 桶排序)   |   [计数排序](# 计数排序)   |   [基数排序](# 基数排序)   |

---

